#![no_std]
use soroban_sdk::{contract, contracterror, contractimpl, Address, Env, Map, String, Symbol};

#[contract]
pub struct WebAuthContract;

#[contracterror]
pub enum WebAuthError {
    MissingArgument = 1,
}

#[contractimpl]
impl WebAuthContract {
    /// Verifies the client is authorized to authenticate with the server
    ///
    /// Arguments:
    /// - account: The client account address
    /// - home_domain: The home domain
    /// - web_auth_domain: The server's domain
    /// - web_auth_domain_account: The server's SIGNING_KEY
    /// - client_domain: The client domain (optional)
    /// - client_domain_account: The client domain's SIGNING_KEY (optional)
    /// - nonce: A random string generated by the server to prevent replay attacks
    pub fn web_auth_verify(env: Env, args: Map<Symbol, String>) -> Result<(), WebAuthError> {
        if let Some(address) = args.get(Symbol::new(&env, "account")) {
            let addr = Address::from_string(&address);
            addr.require_auth();
        } else {
            return Err(WebAuthError::MissingArgument);
        }

        if let Some(web_auth_domain_account) =
            args.get(Symbol::new(&env, "web_auth_domain_account"))
        {
            let addr = Address::from_string(&web_auth_domain_account);
            addr.require_auth();
        } else {
            return Err(WebAuthError::MissingArgument);
        }

        if let Some(client_domain_account) = args.get(Symbol::new(&env, "client_domain_account")) {
            let addr = Address::from_string(&client_domain_account);
            addr.require_auth();
        }

        Ok(())
    }
}
